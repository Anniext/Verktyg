// Code generated by rwmap; DO NOT EDIT.

package ds

import (
	"errors"
	"sync"

	jsoniter "github.com/json-iterator/go"
)

// Map is like a sync.Map, Reduce GC scanning
type RWMapInt32Int8 struct {
	data map[int32]int8
	mu   sync.RWMutex
}

func (m *RWMapInt32Int8) checkData() {
	if m.data == nil {
		m.data = map[int32]int8{}
	}
}

func (m *RWMapInt32Int8) Init() *RWMapInt32Int8 {
	m.mu.Lock()
	m.data = map[int32]int8{}
	m.mu.Unlock()
	return m
}

func (m *RWMapInt32Int8) Change(newMap map[int32]int8) {
	m.mu.Lock()
	m.data = newMap
	m.mu.Unlock()
}

// Load returns the value stored in the map for a key, or nil if no
// value is present.
// The ok result indicates whether value was found in the map.
func (m *RWMapInt32Int8) Load(key int32) (value int8, ok bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	value, ok = m.data[key]
	return
}

// Store sets the value for a key.
func (m *RWMapInt32Int8) Store(key int32, value int8) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.checkData()
	m.data[key] = value
	return
}

// Stores sets the value for a key.
func (m *RWMapInt32Int8) Stores(keys []int32, values []int8) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.checkData()
	for idx, key := range keys {
		m.data[key] = values[idx]
	}
	return
}

// StoreMap sets the value for a key.
func (m *RWMapInt32Int8) StoreMap(tmp map[int32]int8) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.checkData()
	for key, value := range tmp {
		m.data[key] = value
	}
	return
}

// LoadOrStore returns the existing value for the key if present.
// Otherwise, it stores and returns the given value.
// The loaded result is true if the value was loaded, false if stored.
func (m *RWMapInt32Int8) LoadOrStore(key int32, value int8) (actual int8, loaded bool) {
	m.mu.RLock()
	if m.data == nil {
		m.mu.RUnlock()
		m.mu.Lock()
		m.checkData()
		m.mu.Unlock()
		m.mu.RLock()
	}
	actual, loaded = m.data[key]
	m.mu.RUnlock()
	if !loaded {
		m.mu.Lock()
		if actual, loaded = m.data[key]; !loaded {
			m.data[key] = value
			actual = value
		}
		m.mu.Unlock()
	}
	return
}

// LoadAndDelete deletes the value for a key, returning the previous value if any.
// The loaded result reports whether the key was present.
func (m *RWMapInt32Int8) LoadAndDelete(key int32) (value int8, loaded bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.checkData()
	value, loaded = m.data[key]
	if loaded {
		delete(m.data, key)
	}
	return
}

// Delete deletes the value for a key.
func (m *RWMapInt32Int8) Delete(key int32) {
	m.LoadAndDelete(key)
}

// Delete deletes the all value.
func (m *RWMapInt32Int8) DeleteAll() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.checkData()
	length := len(m.data)
	keys := make([]int32, length)
	idx := 0
	for key, _ := range m.data {
		keys[idx] = key
		idx++
	}
	for _, key := range keys {
		delete(m.data, key)
	}
}

// Range calls f sequentially for each key and value present in the map.
// If f returns false, range stops the iteration.
//
// Range does not necessarily correspond to any consistent snapshot of the Map's
// contents: no key will be visited more than once, but if the value for any key
// is stored or deleted concurrently, Range may reflect any mapping for that key
// from any point during the Range call.
//
// Range may be O(N) with the number of elements in the map even if f returns
// false after a constant number of calls.
func (m *RWMapInt32Int8) Range(f func(key int32, value int8) bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	for key, value := range m.data {
		if !f(key, value) {
			break
		}
	}
	return
}

// Items return keys and values present in the map.
func (m *RWMapInt32Int8) Items() (keys []int32, values []int8) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	length := len(m.data)
	keys = make([]int32, length)
	values = make([]int8, length)
	idx := 0
	for key, value := range m.data {
		keys[idx] = key
		values[idx] = value
		idx++
	}
	return
}

// ItemMap return keys and values present in the map.
func (m *RWMapInt32Int8) ItemMap() (tmp map[int32]int8) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	length := len(m.data)
	tmp = make(map[int32]int8, length)
	for key, value := range m.data {
		tmp[key] = value
	}
	return
}

func (m *RWMapInt32Int8) FromDB(data []byte) (err error) {
	if len(data) == 0 {
		m.Init()
		return nil
	}
	err = m.UnmarshalJSON(data)
	return
}

func (m *RWMapInt32Int8) ToDB() (data []byte, err error) {
	data, err = m.MarshalJSON()
	return
}

func (m *RWMapInt32Int8) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte("null"), nil
	}
	m.mu.RLock()
	defer m.mu.RUnlock()
	ret, err := jsoniter.ConfigCompatibleWithStandardLibrary.Marshal(m.data)
	if err != nil {
		return nil, err
	}
	return ret, nil

}

func (m *RWMapInt32Int8) UnmarshalJSON(b []byte) error {
	if m == nil {
		return errors.New(" Unmarshal(non-pointer MapInt32Int8)")
	}
	tmp := map[int32]int8{}
	err := jsoniter.ConfigCompatibleWithStandardLibrary.Unmarshal(b, &tmp)
	if err != nil {
		return err
	}
	if tmp == nil {
		tmp = map[int32]int8{}
	}
	m.Change(tmp)
	return nil
}

func (m *RWMapInt32Int8) String() string {
	if m == nil {
		return "{}"
	}
	data, err := m.MarshalJSON()
	if err != nil {
		return "{}"
	}
	return string(data)
}

// AddStore add the value for a key.
func (m *RWMapInt32Int8) AddStore(key int32, value int8) (ret int8) {
	m.mu.Lock()
	m.checkData()
	ret = m.data[key]
	ret += value
	m.data[key] = ret
	m.mu.Unlock()
	return
}

// AddStores add the values for a keys.
func (m *RWMapInt32Int8) AddStores(keys []int32, values []int8) {
	m.mu.Lock()
	m.checkData()
	for i, key := range keys {
		m.data[key] += values[i]
	}
	m.mu.Unlock()
	return
}
